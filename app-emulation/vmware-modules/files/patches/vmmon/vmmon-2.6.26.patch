diff -Naur vmmon-only/linux/driver.c vmmon-only-new/linux/driver.c
--- vmmon-only/linux/driver.c	2008-05-16 08:59:27.000000000 +0300
+++ vmmon-only-new/linux/driver.c	2008-06-24 05:11:57.000000000 +0300
@@ -23,6 +23,7 @@
 #include <linux/smp_lock.h>
 
 #include <linux/poll.h>
+#include <linux/mm.h>
 
 /*
  * Power Management: hook resume to work around
@@ -179,6 +180,7 @@
 
 static int LinuxDriver_Close(struct inode *inode, struct file *filp);
 static unsigned int LinuxDriverPoll(struct file *file, poll_table *wait);
+#if 0
 #if defined(VMW_NOPAGE_261)
 static struct page *LinuxDriverNoPage(struct vm_area_struct *vma,
                            unsigned long address, int *type);
@@ -188,15 +190,25 @@
 #else
 static unsigned long LinuxDriverNoPage(struct vm_area_struct *vma,
 			   unsigned long address, int write_access);
-#endif
-static int LinuxDriverMmap(struct file *filp, struct vm_area_struct *vma);
-
-static void LinuxDriverPollTimeout(unsigned long clientData);
 
 static struct vm_operations_struct vmuser_mops = {
 	.nopage = LinuxDriverNoPage
 };
 
+#endif
+#else
+static int LinuxDriverNoPage(struct vm_area_struct *vma,
+			   struct vm_fault *fdata);
+
+static struct vm_operations_struct vmuser_mops = {
+	.fault = LinuxDriverNoPage
+};
+
+#endif
+static int LinuxDriverMmap(struct file *filp, struct vm_area_struct *vma);
+
+static void LinuxDriverPollTimeout(unsigned long clientData);
+
 static struct file_operations vmuser_fops;
 static struct timer_list tscTimer;
 
@@ -1173,6 +1185,7 @@
  *-----------------------------------------------------------------------------
  */
 
+#if 0
 #ifdef VMW_NOPAGE_261
 static struct page *LinuxDriverNoPage(struct vm_area_struct *vma, //IN
 				      unsigned long address, 	  //IN
@@ -1207,8 +1220,25 @@
 	return page_address(page);
 #endif
 }
-
-
+#else
+static int LinuxDriverNoPage(struct vm_area_struct *vma,
+			   struct vm_fault *fdata)
+{
+	VMLinux *vmLinux = (VMLinux *) vma->vm_file->private_data;
+	unsigned long pg;
+	struct page* page;
+	
+	pg = fdata->pgoff;
+	pg = VMMON_MAP_OFFSET(pg);
+	if (pg >= vmLinux->size4Gb) {
+		return VM_FAULT_MAJOR;
+	}
+	page = vmLinux->pages4Gb[pg];
+	get_page(page);
+	fdata->page = page;
+        return VM_FAULT_MINOR;
+}
+#endif
 /*
  *-----------------------------------------------------------------------------
  *
diff -Naur vmmon-only/Makefile vmmon-only-new/Makefile
--- vmmon-only/Makefile	2008-07-21 11:32:11.000000000 +0300
+++ vmmon-only-new/Makefile	2008-05-16 10:19:56.000000000 +0300
@@ -82,7 +82,7 @@
 MAKEOVERRIDES := $(filter-out CC=%,$(MAKEOVERRIDES))
 
 $(DRIVER_KO):
-	make -C $(BUILD_DIR) M=$$PWD SRCROOT=$$PWD/$(SRCROOT) modules
+	make -C $(BUILD_DIR) SUBDIRS=$$PWD SRCROOT=$$PWD/$(SRCROOT) modules
 
 else
 
